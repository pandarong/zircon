# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

assert(!defined(current_toolchain), "only for buildconfig context")

declare_args() {
  # *This must never be set as a build argument*.
  #
  # "$zx/" is the prefix for GN "source-absolute" paths in the Zircon
  # build.  When Zircon is built standalone, the Zircon repository is the
  # root of the build (where `.gn` is found) so "$zx/" becomes "//".  When
  # Zircon is part of a larger unified build, there is a higher-level `.gn`
  # file that uses `default_args` to set "$zx/" to "//zircon/".
  zx = "/"
}

# TODO: This distinguishes a standalone Zircon build (where $zx/ is //) from
# an integrated build (where $zx/ is //zircon).  When the integrated build
# is fully cleaned up, this should not matter.
zircon_standalone = zx == "/"

declare_args() {
  # *This must never be set as a build argument.*
  # It exists only to be set via define_toolchain().
  # See define_environment() for more information.
  toolchain = {
    label = "$zx/public/gn/toolchain:stub"
    globals = {
    }
    public_deps = []
  }
}

# The default toolchain is a very boring one.  It can only be used for
# action and copy rules where current_cpu et al don't matter.  Doing
# anything else happens in another toolchain.
set_default_toolchain(toolchain.label)

# The rest of this file pertains to what happens in other toolchains
# defined by define_environment().

# The toolchain can specify pervasive globals.
forward_variables_from(toolchain.globals, "*")

# This is the name for $current_cpu that's used in Zircon file names.
if (current_cpu == "x64") {
  zircon_cpu = "x86"
} else if (current_cpu != "") {
  zircon_cpu = current_cpu
}

# Shorthand for `current_os == "fuchsia"`.
is_fuchsia = current_os == "fuchsia"

# Shorthand for `current_os == "linux"`.
is_linux = current_os == "linux"

# Shorthand for `current_os == "mac"`.
is_mac = current_os == "mac"

if (!defined(is_gcc)) {
  # True iff $current_toolchain builds with GCC rather than Clang.
  is_gcc = false
}

if (!defined(is_host)) {
  # True iff $current_toolchain builds for a host platform rather than for
  # the Fuchsia system being built.  This doesn't mean that it builds for
  # $host_cpu and $host_os--it could be a cross-compilation toolchain for
  # building host tools for a different host.
  is_host = false
}

if (!defined(is_kernel)) {
  # True iff $current_toolchain builds kernel-like code.
  is_kernel = false
}

# Assert in a template that its invoker doesn't use legacy configs.
#
# Always invoked: `assert_no_legacy_configs(target_name) { type = "..." }`
#
# Parameters
#
#   invoker
#     Required: Implicitly set in every template() scope.
#
#   type
#     Required: The name of the calling template().
#
template("assert_no_legacy_configs") {
  label = get_label_info(":$target_name", "label_no_toolchain")
  target_invoker = invoker.invoker
  type = invoker.type
  assert(!defined(target_invoker.all_dependent_configs),
         "all_dependent_configs is not supported in this build")
  assert(!defined(target_invoker.configs),
         "use deps instead of configs in $label $type()")
  assert(!defined(target_invoker.public_configs),
         "use public_deps instead of public_configs in $label $type()")
  not_needed([ "target_invoker" ])
}

# This is used exclusively by config_group(), below.
template("_raw_config") {
  config(target_name) {
    forward_variables_from(invoker, "*")
  }
}

# The primitive GN feature should never be used directly in this build.
# Use config_group() instead.
template("config") {
  _config_label = get_label_info(":$target_name", "label_no_toolchain")
  assert(false, "use config_group() instead of config() for $_config_label")
}

# Propagate switch settings and dependencies to dependents.
#
# config_group() replaces GN's built-in config() with enhanced and
# simplified semantics.  A config_group() is a target that acts like a
# group() target in all respects.  But it can also set all the switches and
# have `inputs` and `libs` like config().  Instead of referring to a
# config() with `configs` or `public_configs`, refer to a config_group()
# with `deps` to take on its switches et al or with `public_deps` to
# propagate its effects to your direct dependents.
#
# Parameters
#
#   compiler_flags
#     Optional: This is appended to all of $asmflags, $cflags, and $ldflags.
#     It's a convenient shorthand for flags that the compiler driver treats
#     the same way for assembling, compiling, and linking tasks.
#
#   data_deps
#   deps
#     Optional: As for group().  This is *not* the way to refer to another
#     config_group() so as to propagate its switch settings; instead use
#     `public_deps` for that.  Note that potentially each individual file
#     compiled with the switches of this config_group() will also have a
#     Ninja dependency arc to each target in `data_deps` or `deps`.  Hence
#     this should be used sparingly.
#
#   public_deps
#     Optional: As for group().  This is the way to refer to other
#     config_group() targets.  Every dependent of this target will also use
#     the switches of theconfig_group() targets in `public_deps`.
#
template("config_group") {
  _config_name = target_name
  _config_label = get_label_info(":$target_name", "label_no_toolchain")

  # The old ways are now taboo.
  assert(!defined(invoker.configs),
         "use public_deps instead of configs in $_config_label config_group()")

  # The underlying config() holds everything but the deps.
  _raw_config("_config.$_config_name") {
    visibility = [ ":$_config_name" ]
    asmflags = []
    cflags = []
    ldflags = []
    forward_variables_from(invoker,
                           "*",
                           [
                             "compiler_flags",
                             "data_deps",
                             "deps",
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    if (defined(invoker.compiler_flags)) {
      asmflags += invoker.compiler_flags
      cflags += invoker.compiler_flags
      ldflags += invoker.compiler_flags
    }
  }

  group(_config_name) {
    forward_variables_from(invoker,
                           [
                             "data_deps",
                             "deps",
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    public_configs = [ ":_config.$_config_name" ]
  }
}

# TODO: for loadable_module, roll into template handling variants
foreach(shlib_target_type,
        [
          "shared_library",
          "loadable_module",
        ]) {
  template(shlib_target_type) {
    assert_no_legacy_configs(target_name) {
      type = shlib_target_type
    }
    if (!defined(toolchain.shlib) || current_toolchain == toolchain.shlib) {
      # This is the toolchain that actually builds the libraries.
      target(shlib_target_type, target_name) {
        forward_variables_from(invoker, "*", [ "visibility" ])
        forward_variables_from(invoker, [ "visibility" ])
        if (defined(visibility) && defined(toolchain.shlib)) {
          # Make sure we're visible to the redirector groups defined below.
          visibility += [ ":$target_name" ]
        }
      }
    } else {
      # In the main toolchain, just redirect to the shlib toolchain.
      group(target_name) {
        forward_variables_from(invoker,
                               [
                                 "testonly",
                                 "visibility",
                               ])
        not_needed(invoker, "*")
        public_deps = [
          ":$target_name(${toolchain.shlib})",
        ]
      }
    }
  }
}

template("library") {
  _library_name = target_name
  host = defined(invoker.host) && invoker.host
  kernel = defined(invoker.kernel) && invoker.kernel
  shared = defined(invoker.shared) && invoker.shared
  if (defined(invoker.static)) {
    static = invoker.static
  } else {
    static = !kernel
  }
  _library_params = [
    "kernel",
    "host",
    "shared",
    "static",
  ]
  assert(host || kernel || static || shared,
         "library(\"$target_name\") must build somewhere!")

  # Not all of these will be referenced in all toolchains.
  not_needed(_library_params)

  # A specialized toolchain might not support shared libraries.
  shared = shared && defined(toolchain.shlib)

  # Empty libraries are useless, so do a source set instead.
  # TODO(crbug.com/gn/16): Empty library works OK and the source_set
  # case tickles a GN bug.  Remove `&& false` when the bug is fixed.
  if (invoker.sources == [] && false) {
    static_library = "source_set"
  } else {
    static_library = "static_library"
  }
  not_needed([ "static_library" ])

  targets = false
  if (is_kernel) {
    if (kernel) {
      targets = true
      source_set(_library_name) {
        forward_variables_from(invoker, "*", _library_params)
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":${_library_name}.headers" ]
      }
    }
  } else if (is_host) {
    if (host) {
      targets = true
      target(static_library, _library_name) {
        forward_variables_from(invoker, "*", _library_params)
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":${_library_name}.headers" ]
      }
    }
  } else if (static || shared) {
    targets = true
    source_set("${_library_name}._sources") {
      visibility = [
        ":${_library_name}.static",
        ":${_library_name}.shared",
      ]
      forward_variables_from(invoker,
                             "*",
                             _library_params + [
                                   "install_path",
                                   "public_deps",
                                   "visibility",
                                 ])
      deps += [ ":${_library_name}.headers" ]
    }
    if (static) {
      target(static_library, "${_library_name}.static") {
        output_name = _library_name
        forward_variables_from(invoker,
                               [
                                 "public_deps",
                                 "testonly",
                                 "visibility",
                               ])
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":${_library_name}.headers" ]
        deps = [
          ":${_library_name}._sources",
        ]
      }
    }
    if (shared) {
      if (defined(invoker.install_path)) {  #TODO
        not_needed(invoker, [ "install_path" ])
      }
      shared_library("${_library_name}.shared") {
        output_name = _library_name
        forward_variables_from(invoker,
                               [
                                 "ldflags",
                                 "libs",
                                 "lib_dirs",
                                 "testonly",
                                 "visibility",
                               ])

        # Everything that depends on the library gets the headers.
        # It also gets the explicit `public_deps`, which includes
        # any header dependencies or public config_group()s.
        public_deps = [
          ":${_library_name}.headers",
        ]
        if (defined(invoker.public_deps)) {
          public_deps += invoker.public_deps
        }

        # The library depends on the source_set().  It also depends on the
        # `deps` from the source_set() so as to get any config_group()
        # dependencies that affect linking rather than just compilation.
        # Other dependencies are redundant since the source_set() already
        # has them, but they don't hurt.
        deps = [
          ":${_library_name}._sources",
        ]
        if (defined(invoker.deps)) {
          deps += invoker.deps
        }
      }
    }
    group(_library_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      if (shared) {
        public_deps = [
          ":${_library_name}.shared",
        ]
      } else {
        public_deps = [
          ":${_library_name}.static",
        ]
      }
    }
  }

  if (!targets) {
    # In this toolchain there are no actual targets, only the headers.
    not_needed(invoker, "*")
    group(_library_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      public_deps = [
        ":${_library_name}.headers",
      ]
    }
  }

  config_group("${_library_name}.headers") {
    include_dirs = [ "include" ]

    # The public_deps here represent header dependencies.
    forward_variables_from(invoker,
                           [
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    if (defined(visibility)) {
      visibility += [ "$:_library_name" ]
      if (!is_kernel) {
        visibility += [
          ":${_library_name}.sources",
          ":${_library_name}.static",
          ":${_library_name}.shared",
        ]
      }
    }
  }

  # If this library is the main target for the directory, then give its
  # auxiliary targets aliases `dir:headers`, `dir:static`, `dir:shared`.
  if (get_label_info(":$_library_name", "name") ==
      get_path_info(get_label_info(":$_library_name", "dir"), "file")) {
    group("headers") {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      public_deps = [
        ":${_library_name}.headers",
      ]
    }
    if (!is_kernel && !is_host) {
      if (static) {
        group("static") {
          forward_variables_from(invoker,
                                 [
                                   "testonly",
                                   "visibility",
                                 ])
          public_deps = [
            ":${_library_name}.static",
          ]
        }
      }
      if (shared) {
        group("shared") {
          forward_variables_from(invoker,
                                 [
                                   "testonly",
                                   "visibility",
                                 ])
          public_deps = [
            ":${_library_name}.shared",
          ]
        }
      }
    }
  }
}

# TODO: more later
template("host_tool") {
  assert_no_legacy_configs(target_name) {
    type = "host_tool"
  }
  executable(target_name) {
    forward_variables_from(invoker, "*", [ "visibility" ])
    forward_variables_from(invoker, [ "visibility" ])
  }
}

template("driver") {
  loadable_module(target_name) {
    deps = []
    forward_variables_from(invoker, "*", [ "visibility" ])
    forward_variables_from(invoker, [ "visibility" ])
    deps += [
      "$zx/system/ulib/ddk",
      "$zx/system/ulib/driver",
    ]
    data_deps = [
      "$zx/system/core/devmgr:devhost",
    ]

    if (!defined(install_path)) {
      #TODO: install_path = "driver/" + ...
    }
  }
}

template("test_driver") {
  driver(target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "install_path",
                             "visibility",
                           ])
    forward_variables_from(invoker, [ "visibility" ])
    if (!defined(output_name)) {
      output_name = target_name
    }

    #TODO: install_path = "driver/test/${output_name}.so"
    testonly = true
  }
}

# Just wrap these to inject assert_no_legacy_configs().
foreach(target_type,
        [
          "source_set",
          "static_library",
        ]) {
  template(target_type) {
    assert_no_legacy_configs(target_name) {
      type = target_type
    }
    target(target_type, target_name) {
      forward_variables_from(invoker, "*", [ "visibility" ])
      forward_variables_from(invoker, [ "visibility" ])
    }
  }
}

# These are what we call the "terminal" target types: they are linked
# artifacts that get explicitly installed on a device (or run on a host).
# static_library() and source_set() aren't terminal because they don't link.
# shared_library() isn't terminal because it gets installed only implicitly as
# a dependency of another target (either another library or a terminal
# target).  So these are the base target types that participate directly in
# variant selection.
_terminal_target_types = [
  "driver",
  "executable",
  "host_tool",
  "loadable_module",
  "test_driver",
]

# These are all the target types (both stock GN and Fuchsia templates) that
# compile `sources` with the $current_toolchain tools.  All these get a
# default `deps` below, so their targets use `deps += ...` normally.
_compile_target_types = [
  "driver",
  "executable",
  "host_tool",
  "library",
  "loadable_module",
  "shared_library",
  "source_set",
  "static_library",
  "test_driver",
]

# ${toolchain.public_deps} gives the initial `deps` set for every compile
# target in this toolchain.  This is how `configs` is used traditionally in
# GN: targets use `+=` rather than `=` unless they are explicitly doing `= []`
# to remove all the toolchain defaults; they can use `-=` to remove specific
# members from the default set.  In the Fuchsia build, `deps` is used in lieu
# of `configs`; see config_group(), which replaces config().
foreach(target_type, _compile_target_types) {
  set_defaults(target_type) {
    deps = toolchain.public_deps
    if (is_fuchsia && target_type == "host_tool") {
      deps += [ "$zx/system/ulib/fdio" ]
    }
  }
}
