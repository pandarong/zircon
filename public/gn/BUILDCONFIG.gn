# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

assert(!defined(current_toolchain), "only for buildconfig context")

declare_args() {
  # *This must never be set as a build argument*.
  #
  # "$zx/" is the prefix for GN "source-absolute" paths in the Zircon
  # build.  When Zircon is built standalone, the Zircon repository is the
  # root of the build (where `.gn` is found) so "$zx/" becomes "//".  When
  # Zircon is part of a larger unified build, there is a higher-level `.gn`
  # file that uses `default_args` to set "$zx/" to "//zircon/".
  zx = "/"
}

# TODO: This distinguishes a standalone Zircon build (where $zx/ is //) from
# an integrated build (where $zx/ is //zircon).  When the integrated build
# is fully cleaned up, this should not matter.
zircon_standalone = zx == "/"

declare_args() {
  # *This must never be set as a build argument.*
  # It exists only to be set via define_toolchain().
  # See define_environment() for more information.
  toolchain = {
    configs = []
    environment = "stub"
    label = "$zx/public/gn/toolchain:stub"
    globals = {
    }
  }
}

# The default toolchain is a very boring one.  It can only be used for
# action and copy rules where current_cpu et al don't matter.  Doing
# anything else happens in another toolchain.
set_default_toolchain(toolchain.label)

# The rest of this file pertains to what happens in other toolchains
# defined by define_environment().

# The toolchain can specify pervasive globals.
forward_variables_from(toolchain.globals, "*")

# This is the name for $current_cpu that's used in Zircon file names.
if (current_cpu == "x64") {
  zircon_cpu = "x86"
} else if (current_cpu != "") {
  zircon_cpu = current_cpu
}

# Shorthand for `current_os == "fuchsia"`.
is_fuchsia = current_os == "fuchsia"

# Shorthand for `current_os == "linux"`.
is_linux = current_os == "linux"

# Shorthand for `current_os == "mac"`.
is_mac = current_os == "mac"

if (!defined(is_gcc)) {
  # True iff $current_toolchain builds with GCC rather than Clang.
  is_gcc = false
}

if (!defined(is_host)) {
  # True iff $current_toolchain builds for a host platform rather than for
  # the Fuchsia system being built.  This doesn't mean that it builds for
  # $host_cpu and $host_os--it could be a cross-compilation toolchain for
  # building host tools for a different host.
  is_host = false
}

if (!defined(is_kernel)) {
  # True iff $current_toolchain builds kernel-like code.
  is_kernel = false
}

###
### config() revamp
###

# Assert in a template that its invoker doesn't use legacy configs.
#
# Always invoked: `assert_no_legacy_configs(target_name) { type = "..." }`
#
# Parameters
#
#   invoker
#     Required: Implicitly set in every template() scope.
#
#   type
#     Required: The name of the calling template().
#
template("assert_no_legacy_configs") {
  label = get_label_info(":$target_name", "label_no_toolchain")
  target_invoker = invoker.invoker
  type = invoker.type
  assert(!defined(target_invoker.all_dependent_configs),
         "all_dependent_configs is not supported in this build")
  assert(!defined(target_invoker.public_configs),
         "use public_deps instead of public_configs in $label $type()")
  not_needed([ "target_invoker" ])
}

# This is used exclusively by the config() template, below.
template("_raw_config") {
  config(target_name) {
    forward_variables_from(invoker, "*")
  }
}

# Propagate switch settings and dependencies to dependents.
#
# This template replaces GN's built-in config() with enhanced and
# simplified semantics.  A config() is a target that acts like a group()
# target in all respects.  But it can also set all the switches and have
# `inputs` and `libs` like legacy config().

# By convention, a config() is usually referred to in `configs`, but in
# fact all the compiling target types are templates that just merge
# `configs` into `deps` and putting a config() label into `deps` works just
# the same.  The main reason for the convention is just that `configs` is
# usually predefined with a default list via set_defaults() so `configs -=
# ...` can remove default elements, while `deps` is not.
#
# A config() itself never sets `configs` or `public_configs` like in legacy
# config().  Instead use `public_deps` for another config() that should be
# propagated to users of this config().
#
# Parameters
#
#   compiler_flags
#     Optional: This is appended to all of $asmflags, $cflags, and $ldflags.
#     It's a convenient shorthand for flags that the compiler driver treats
#     the same way for assembling, compiling, and linking tasks.
#
#   data_deps
#   deps
#     Optional: As for group().  This is *not* the way to refer to another
#     config() so as to propagate its switch settings; instead use
#     `public_deps` for that.  Note that potentially each individual file
#     compiled with the switches of this config() will also have a
#     Ninja dependency arc to each target in `data_deps` or `deps`.  Hence
#     this should be used sparingly.
#
#   public_deps
#     Optional: As for group().  This is the way to refer to other
#     config() targets.  Every dependent of this target will also use
#     the switches of the config() targets in `public_deps`.
#
template("config") {
  _config_name = target_name
  _config_label = get_label_info(":$target_name", "label_no_toolchain")

  # The old ways are now taboo.
  assert(!defined(invoker.configs),
         "use public_deps instead of configs in $_config_label config()")
  assert(!defined(invoker.public_configs),
         "use public_deps instead of public_configs in $_config_label config()")

  # The underlying config() holds everything but the deps.
  _raw_config("_config.$_config_name") {
    visibility = [ ":$_config_name" ]
    asmflags = []
    cflags = []
    ldflags = []
    forward_variables_from(invoker,
                           "*",
                           [
                             "compiler_flags",
                             "data_deps",
                             "deps",
                             "metadata",
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    if (defined(invoker.compiler_flags)) {
      asmflags += invoker.compiler_flags
      cflags += invoker.compiler_flags
      ldflags += invoker.compiler_flags
    }
  }

  group(_config_name) {
    forward_variables_from(invoker,
                           [
                             "data_deps",
                             "deps",
                             "metadata",
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    public_configs = [ ":_config.$_config_name" ]

    metadata = {
      forward_variables_from(invoker,
                             [
                               "ldflags",
                               "lib_dirs",
                               "libs",
                             ])
      if (defined(invoker.compiler_flags)) {
        if (!defined(ldflags)) {
          ldflags = []
        }
        ldflags += invoker.compiler_flags
      }
    }
  }
}

###
### "Non-terminal" (library and source_set) target types.
### These are compiling targets that never do variant selection.
###

# Just wrap these to inject assert_no_legacy_configs()
# and translate configs to deps.
foreach(target_type,
        [
          "source_set",
          "static_library",
        ]) {
  template(target_type) {
    assert_no_legacy_configs(target_name) {
      type = target_type
    }
    target(target_type, target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "configs",
                               "deps",
                               "visibility",
                             ])
      forward_variables_from(invoker, [ "visibility" ])
      deps = invoker.configs
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
    }
  }
}

# This is for doing the actual shared_library() or loadable_module()
# target in a toolchain that supports them directly.  That is, either
# ${toolchain.label} == ${toolchain.shlib} or this is a toolchain that
# was defined with `solink = true` so there is no ${toolchain.shlib}.
template("_shlib_toolchain_target") {
  assert_no_legacy_configs(target_name) {
    type = invoker.target_type
  }
  assert(!is_kernel,
         "${invoker.target_type}() targets don't work in kernel toolchains")

  target(invoker.target_type, target_name) {
    # visibility and data_deps get special treatment in ${toolchain.shlib}.
    if (defined(toolchain.shlib)) {
      if (defined(invoker.visibility)) {
        # Make sure we're visible to the redirector groups defined below.
        visibility = invoker.visibility + [ ":$target_name" ]
      }
      if (defined(invoker.data_deps)) {
        # Redirect data_deps to the non-shlib toolchain.
        data_deps = []
        foreach(label, invoker.data_deps) {
          if (get_label_info(label, "toolchain") == current_toolchain) {
            label += "(${toolchain.label})"
          }
          data_deps += [ label ]
        }
      }
    } else {
      forward_variables_from(invoker,
                             [
                               "data_deps",
                               "visibility",
                             ])
    }

    # Everything else is passed through (everything in solink toolchains).
    # But also apply configs->deps.
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "deps",
                             "data_deps",
                             "target_type",
                             "visibility",
                           ])
    deps = invoker.configs
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }
}

template("shared_library") {
  if (!defined(toolchain.shlib) || current_toolchain == toolchain.shlib) {
    # This is the toolchain that actually builds the libraries.
    _shlib_toolchain_target(target_name) {
      target_type = "shared_library"
      forward_variables_from(invoker,
                             "*",
                             [
                               "metadata",
                               "target_type",
                               "visibility",
                             ])
      forward_variables_from(invoker, [ "visibility" ])

      if (!defined(output_name)) {
        output_name = target_name
      }
      output_name += toolchain.output_name_suffix
      if (!defined(output_extension)) {
        output_extension = "so"
      }
      output_file = "$target_out_dir/lib$output_name"
      if (output_extension != "") {
        output_file += ".$output_extension"
      }

      metadata = {
        link_output = [ output_file ]
        link_output_arg = rebase_path(link_output, root_build_dir)
        link_barrier = []

        # Each shared_library() that's not on the whitelist gets a poison
        # pill to flag it if it appears in the dependency graph from a
        # driver() target.
        if (defined(invoker.metadata)) {
          forward_variables_from(invoker.metadata, "*")
        }
        if (!defined(driver_blacklist)) {
          driver_blacklist = [ true ]
        }
      }
    }
  } else {
    # In the main toolchain, just redirect to the shlib toolchain.
    group(target_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      not_needed(invoker, "*")
      public_deps = [
        ":$target_name(${toolchain.shlib})",
      ]
    }
  }
}

template("library") {
  _library_name = target_name
  host = defined(invoker.host) && invoker.host
  kernel = defined(invoker.kernel) && invoker.kernel
  shared = defined(invoker.shared) && invoker.shared
  if (defined(invoker.static)) {
    static = invoker.static
  } else {
    static = !kernel
  }
  _library_params = [
    "kernel",
    "host",
    "shared",
    "static",
  ]
  assert(host || kernel || static || shared,
         "library(\"$target_name\") must build somewhere!")

  # Not all of these will be referenced in all toolchains.
  not_needed(_library_params)

  # A specialized toolchain might not support shared libraries.
  shared = shared && defined(toolchain.shlib)

  # Empty libraries are useless, so do a source set instead.
  # TODO(crbug.com/gn/16): Empty library works OK and the source_set
  # case tickles a GN bug.  Remove `&& false` when the bug is fixed.
  if (invoker.sources == [] && false) {
    static_library = "source_set"
  } else {
    static_library = "static_library"
  }
  not_needed([ "static_library" ])

  targets = false
  if (is_kernel) {
    if (kernel) {
      targets = true
      source_set(_library_name) {
        forward_variables_from(invoker, "*", _library_params)
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":${_library_name}.headers" ]
      }
    }
  } else if (is_host) {
    if (host) {
      targets = true
      target(static_library, _library_name) {
        if (static_library == "static_library") {
          complete_static_lib = true
        }
        forward_variables_from(invoker, "*", _library_params)
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":${_library_name}.headers" ]
      }
    }
  } else if (static || shared) {
    targets = true
    source_set("${_library_name}._sources") {
      visibility = [
        ":${_library_name}.static",
        ":${_library_name}.shared",
      ]
      forward_variables_from(invoker,
                             "*",
                             _library_params + [
                                   "data_deps",
                                   "install_path",
                                   "public_deps",
                                   "visibility",
                                 ])
      if (!defined(deps)) {
        deps = []
      }
      deps += [ ":${_library_name}.headers" ]
      if (defined(invoker.data_deps)) {
        # Redirect data_deps to the non-shlib toolchain.
        data_deps = []
        foreach(label, invoker.data_deps) {
          if (get_label_info(label, "toolchain") == current_toolchain) {
            label += "(${toolchain.label})"
          }
          data_deps += [ label ]
        }
      }
    }
    if (static) {
      target(static_library, "${_library_name}.static") {
        if (static_library == "static_library") {
          complete_static_lib = true
        }
        output_name = _library_name
        forward_variables_from(invoker,
                               [
                                 "configs",
                                 "data_deps",
                                 "public_deps",
                                 "testonly",
                                 "visibility",
                               ])
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":${_library_name}.headers" ]
        deps = [
          ":${_library_name}._sources",
        ]
      }
    }
    if (shared) {
      if (defined(invoker.install_path)) {
        install_path = invoker.install_path
      } else {
        # TODO: toolchain prefix for asan, xray
        install_path = "lib/lib${_library_name}.so"
      }
      shared_library("${_library_name}.shared") {
        output_name = _library_name
        forward_variables_from(invoker,
                               [
                                 "configs",
                                 "ldflags",
                                 "libs",
                                 "lib_dirs",
                                 "testonly",
                                 "visibility",
                               ])

        # Everything that depends on the library gets the headers.
        # It also gets the explicit `public_deps`, which includes
        # any header dependencies or public config()s.
        public_deps = [
          ":${_library_name}.headers",
        ]
        if (defined(invoker.public_deps)) {
          public_deps += invoker.public_deps
        }

        # The library depends on the source_set().  It also depends on the
        # `deps` from the source_set() so as to get any config()
        # dependencies that affect linking rather than just compilation.
        # Other dependencies are redundant since the source_set() already
        # has them, but they don't hurt.
        deps = [
          ":${_library_name}._sources",
        ]
        if (defined(invoker.deps)) {
          deps += invoker.deps
        }

        # An explicit `install_path = false` means this DSO is not installed.
        if (install_path != false) {
          metadata = {
            manifest_inputs = [ "$target_out_dir/lib${output_name}.so" ]
            manifest_lines = [ "${install_path}=" +
                               rebase_path(manifest_inputs[0], root_build_dir) ]
          }

          # TODO(get_metadata): dismal kludge in the absence of get_metadata()
          data =
              rebase_path(rebase_path([
                                        "$target_gen_dir/$target_name.manifest",
                                        "$target_gen_dir/$target_name.d",
                                      ],
                                      root_gen_dir,
                                      root_build_dir),
                          "",
                          "$root_build_dir/bootfs-$current_cpu")
          write_file(data[0], metadata.manifest_lines)
          write_file(data[1],
                     rebase_path(metadata.manifest_inputs, root_build_dir))
        }
      }
    }
    group(_library_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      if (shared) {
        public_deps = [
          ":${_library_name}.shared",
        ]
      } else {
        public_deps = [
          ":${_library_name}.static",
        ]
      }
    }
  }

  if (!targets) {
    # In this toolchain there are no actual targets, only the headers.
    not_needed(invoker, "*")
    group(_library_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      public_deps = [
        ":${_library_name}.headers",
      ]
    }
  }

  config("${_library_name}.headers") {
    include_dirs = [ "include" ]

    # The public_deps here represent header dependencies.
    forward_variables_from(invoker,
                           [
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    if (defined(visibility)) {
      visibility += [ ":$_library_name" ]
      if (!is_kernel) {
        visibility += [
          ":${_library_name}.sources",
          ":${_library_name}.static",
          ":${_library_name}.shared",
        ]
      }
    }
  }

  # If this library is the main target for the directory, then give its
  # auxiliary targets aliases `dir:headers`, `dir:static`, `dir:shared`.
  if (get_label_info(":$_library_name", "name") ==
      get_path_info(get_label_info(":$_library_name", "dir"), "file")) {
    group("headers") {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      public_deps = [
        ":${_library_name}.headers",
      ]
    }
    if (!is_kernel && !is_host) {
      if (static) {
        group("static") {
          forward_variables_from(invoker,
                                 [
                                   "testonly",
                                   "visibility",
                                 ])
          public_deps = [
            ":${_library_name}.static",
          ]
        }
      }
      if (shared) {
        group("shared") {
          forward_variables_from(invoker,
                                 [
                                   "testonly",
                                   "visibility",
                                 ])
          public_deps = [
            ":${_library_name}.shared",
          ]
        }
      }
    }
  }
}

###
### "Terminal" (executable and loadable_module) target types.
### These are the targets that do variant selection.
###

template("_variant_target") {
  target = {
    forward_variables_from(invoker.target, "*")
    if (!defined(match)) {
      match = type
    }
  }
  assert_no_legacy_configs(target_name) {
    type = target.match
  }

  if (toolchain.variant_selectors == []) {
    # This toolchain does not participate in variant selection.
    builder_toolchain = current_toolchain
  } else {
    # The first matching variant selector determines which toolchain actually
    # builds this target.
    builder_toolchain = false
    foreach(selector, toolchain.variant_selectors) {
      match = true
      if (selector.cpu != []) {
        if (selector.cpu + [ current_cpu ] - [ current_cpu ] == selector.cpu) {
          match = false
        }
      }
      if (selector.dir != []) {
        dir = get_label_info(":$target_name", "dir")
        if (selector.dir + [ dir ] - [ dir ] == selector.dir) {
          match = false
        }
      }
      if (selector.environment != []) {
        if (selector.environment + [ toolchain.environment ] -
            [ toolchain.environment ] == selector.environment &&
            selector.environment + [ toolchain.base_environment ] -
            [ toolchain.base_environment ] == selector.environment) {
          match = false
        }
      }
      if (selector.label != []) {
        label = get_label_info(":$target_name", "label_no_toolchain")
        if (selector.label + [ label ] - [ label ] == selector.label) {
          match = false
        }
      }
      if (selector.name != []) {
        name = get_name_info(":$target_name", "name_no_toolchain")
        if (selector.name + [ name ] - [ name ] == selector.name) {
          match = false
        }
      }
      if (selector.os != []) {
        if (selector.os + [ current_os ] - [ current_os ] == selector.os) {
          match = false
        }
      }
      if (selector.output_name != []) {
        if (defined(invoker.output_name)) {
          output_name = invoker.output_name
        } else {
          output_name = target_name
        }
        if (selector.output_name + [ output_name ] - [ output_name ] ==
            selector.output_name) {
          match = false
        }
      }
      if (selector.target_type != []) {
        if (selector.target_type + [ target.match ] - [ target.match ] ==
            selector.target_type) {
          match = false
        }
      }
      if (defined(selector.host) && selector.host != is_host) {
        match = false
      }
      if (defined(selector.kernel) && selector.kernel != is_kernel) {
        match = false
      }
      if (match && builder_toolchain == false) {
        if (defined(target.shlib) && target.shlib &&
            defined(selector.shlib_toolchain)) {
          builder_toolchain = selector.shlib_toolchain
        } else {
          builder_toolchain = selector.toolchain
        }
      }
    }
    assert(builder_toolchain != false)
  }

  main_target_name = target_name
  done_main_target = builder_toolchain != current_toolchain
  if (done_main_target) {
    # In other toolchains, the main target just redirects to builder_toolchain.
    group(main_target_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      not_needed(invoker, "*")
      public_deps = [
        ":$main_target_name($builder_toolchain)",
      ]
    }

    if (defined(target.variant_suffix_metadata)) {
      # We'll define a real variant-suffixed target in every variant.
      builder_toolchain = current_toolchain
    }
  }

  if (builder_toolchain == current_toolchain) {
    builder_target_name = main_target_name
    builder_output_name = invoker.output_name
    if (defined(target.variant_suffix_metadata)) {
      # Define the real target with its variant suffixed target_name and
      # output_name.
      builder_target_name += toolchain.variant_suffix
      builder_output_name += toolchain.variant_suffix
    }

    target(target.type, builder_target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "output_name",
                               "target",
                               "visibility",
                             ])
      output_name = builder_output_name
      if (defined(invoker.visibility)) {
        # Make sure we're visible to the redirector groups defined below.
        visibility = invoker.visibility + [
                       ":$builder_target_name",
                       ":$main_target_name",
                     ]
      }
    }

    if (!done_main_target) {
      if (defined(target.variant_suffix_metadata)) {
        if (defined(target.variant_suffix_outputs)) {
          alias_type = "copy"
        } else {
          alias_type = "group"
        }
        target(alias_type, main_target_name) {
          forward_variables_from(invoker,
                                 [
                                   "testonly",
                                   "visibility",
                                 ])
          deps = [
            ":${builder_target_name}($builder_toolchain)",
          ]
          if (alias_type == "copy") {
            outputs = target.variant_suffix_outputs
            sources = [
              "$target_out_dir/${invoker.output_name}${toolchain.variant_suffix}",
            ]
            if (defined(invoker.output_extension) &&
                invoker.output_extension != "") {
              sources[0] += ".${invoker.output_extension}"
            }
          }
          metadata = target.variant_suffix_metadata
          if (defined(visibility)) {
            # Make sure we're visible to the redirector groups defined below.
            visibility += [ ":$target_name" ]
          }
        }
      }
    }
  }

  # Now define a suffixed redirector for each other variant's suffix.
  foreach(other, toolchain.other_variants) {
    other_target_name = main_target_name + other.suffix
    group(other_target_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      public_deps = [
        ":$other_target_name(${other.label})",
      ]
    }
  }
}

template("_basic_executable") {
  assert_no_legacy_configs(target_name) {
    type = invoker.target_type
  }
  _variant_target(target_name) {
    target = {
      match = invoker.target_type
      type = "executable"
      forward_variables_from(invoker,
                             [
                               "variant_suffix_metadata",
                               "variant_suffix_outputs",
                             ])
    }
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "deps",
                             "metadata",
                             "target",
                             "visibility",
                           ])
    forward_variables_from(invoker, [ "visibility" ])
    deps = invoker.configs
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    if (!defined(output_name)) {
      output_name = target_name
    }
    output_name += toolchain.output_name_suffix
    if (!defined(output_extension)) {
      output_extension = toolchain.executable_extension
    }
    output_file = "$target_out_dir/$output_name"
    if (output_extension != "") {
      output_file += ".$output_extension"
    }

    metadata = {
      if (defined(invoker.metadata)) {
        forward_variables_from(invoker.metadata, "*")
      }
      link_output = [ output_file ]
      link_output_arg = rebase_path(link_output, root_build_dir)
      link_barrier = []
    }

    if (!is_host && !is_kernel) {
      # An explicit `install_path = false` means this binary is not installed.
      if (!defined(install_path)) {
        install_path = "bin/" + get_path_info(output_file, "file")
      }
      if (install_path != false) {
        metadata.manifest_inputs = [ output_file ]
        metadata.manifest_lines =
            [ "${install_path}=" + rebase_path(output_file, root_build_dir) ]
      }

      # Also define an alias with the variant suffix.  _variant_target will
      # make this redirect to the specific variant toolchain chosen for
      # this target.  In only that toolchain, the metadata will give the
      # binary a second install path with the variant suffix.
      target.variant_suffix_metadata = {
        manifest_lines = [ "${install_path}${toolchain.variant_suffix}=" +
                           rebase_path(output_file, root_build_dir) ]
      }

      # TODO(get_metadata): dismal kludge in the absence of get_metadata()
      if (defined(metadata) && current_toolchain == toolchain.label) {
        data =
            rebase_path(rebase_path([
                                      "$target_gen_dir/$target_name.manifest",
                                      "$target_gen_dir/$target_name.d",
                                    ],
                                    root_gen_dir,
                                    root_build_dir),
                        "",
                        "$root_build_dir/bootfs-$current_cpu")
        write_file(data[0], metadata.manifest_lines)
        write_file(data[1],
                   rebase_path(metadata.manifest_inputs, root_build_dir))
      }
    }
  }
}

template("loadable_module") {
  assert(!is_kernel)
  assert(!is_host)
  _variant_target(target_name) {
    # This is for _variant_target().
    target = {
      shlib = true
      match = "loadable_module"
      type = "_shlib_toolchain_target"
    }

    # This is for _shlib_toolchain_target().
    target_type = "loadable_module"
    forward_variables_from(invoker,
                           "*",
                           [
                             "metadata",
                             "target_type",
                             "visibility",
                           ])
    forward_variables_from(invoker, [ "visibility" ])

    if (!defined(output_name)) {
      output_name = target_name
    }
    output_name += toolchain.output_name_suffix
    if (!defined(output_extension)) {
      output_extension = "so"
    }
    output_file = "$target_out_dir/$output_name"
    if (output_extension != "") {
      output_file += ".$output_extension"
    }

    metadata = {
      link_output = [ output_file ]
      link_output_arg = rebase_path(link_output, root_build_dir)
      link_barrier = []

      if (defined(invoker.install_path)) {
        manifest_inputs = []
        manifest_lines = []
        if (defined(invoker.metadata)) {
          forward_variables_from(invoker.metadata, "*")
        }
        manifest_inputs += [ output_file ]
        manifest_lines +=
            [ "${install_path}=" + rebase_path(output_file, root_build_dir) ]
      }
    }

    if (defined(invoker.install_path)) {
      # Also define an alias with the variant suffix.  _variant_target will
      # make this redirect to the specific variant toolchain chosen for
      # this target.  In only that toolchain, the metadata will give the
      # binary a second install path with the variant suffix.
      target.variant_suffix_metadata = {
        manifest_inputs = [ output_file ]
        manifest_lines = [ get_path_info(invoker.install_path, "dir") + "/" +
                           get_path_info(invoker.install_path, "name") +
                           toolchain.variant_suffix +
                           get_path_info(invoker.install_path, "extension") +
                           "=" + rebase_path(output_file, root_build_dir) ]
      }
    }

    # TODO(get_metadata): dismal kludge in the absence of get_metadata()
    if (defined(invoker.install_path) && invoker.install_path != false &&
        (!defined(toolchain.shlib) || current_toolchain == toolchain.shlib)) {
      data = rebase_path(rebase_path([
                                       "$target_gen_dir/$target_name.manifest",
                                       "$target_gen_dir/$target_name.d",
                                     ],
                                     root_gen_dir,
                                     root_build_dir),
                         "",
                         "$root_build_dir/bootfs-$current_cpu")
      write_file(data[0], metadata.manifest_lines)
      write_file(data[1], rebase_path(metadata.manifest_inputs, root_build_dir))
    }
  }
}

if (!defined(toolchain.devhost_suffix)) {
  toolchain.devhost_suffix = ""
}

template("driver") {
  loadable_module(target_name) {
    data_deps = []
    deps = []
    forward_variables_from(invoker, "*", [ "visibility" ])
    forward_variables_from(invoker, [ "visibility" ])

    # All drivers implicitly get the driver ABI.
    deps += [ "$zx/system/ulib/driver" ]

    # Drivers that use C++ library facilities cannot use the libc++
    # shared library (it's not in the whitelist).  So always use the
    # hermetic static library.  This has no effect if no C++ library
    # symbols are used.
    configs += [ "$zx/public/gn/config:static-libc++" ]

    # A driver depends on devhost being on the system.  Toolchains like
    # ASan need a compatible devhost for their drivers to be loaded in.
    # They define ${toolchain.devhost_suffix} so that this dependency and
    # devhost target definition are distinct from generic devhost.
    data_deps +=
        [ "$zx/system/core/devmgr/devhost:devhost" + toolchain.devhost_suffix ]

    # It's an error to link against any shared library that's not on the
    # whitelist.  Those libraries set `driver_blackist=[]` while others (by
    # default, see shared_library() above) set `driver_blacklist=[true]`.
    if (false) {  # TODO(get_metadata)
      assert_no_metadata("",
                         [ "driver_blacklist" ],
                         [ "driver_blacklist_barrier" ],
                         "driver() targets cannot depend on shared libraries")
    }

    # Set the standard install_path.
    if (!defined(output_name)) {
      output_name = target_name
    }
    if (!defined(install_path)) {
      install_path = "driver/${output_name}.so"
    }
  }
}

template("test_driver") {
  driver(target_name) {
    testonly = true
    forward_variables_from(invoker,
                           "*",
                           [
                             "install_path",
                             "visibility",
                           ])
    forward_variables_from(invoker, [ "visibility" ])
    if (!defined(output_name)) {
      output_name = target_name
    }
    install_path = "driver/test/${output_name}.so"
  }
}

if (!is_host && !is_kernel &&
    # TODO(get_metadata): shlib exclusion only needed due to dismal kludge
    defined(toolchain.shlib) && toolchain.label != toolchain.shlib) {
  template("executable") {
    executable_name = target_name
    action(executable_name) {  # TODO(get_metadata): oy upon oy
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      script = "/usr/bin/touch"
      outputs = [
        "$target_out_dir/$executable_name.bogostamp",
      ]
      args = rebase_path(outputs, root_build_dir)
      data_deps = [
        ":_bin.$executable_name",
      ]
    }
    _basic_executable("_bin.$executable_name") {  # TODO(get_metadata): just target_name
      target_type = "executable"
      forward_variables_from(invoker, "*", [ "visibility" ])
      forward_variables_from(invoker, [ "visibility" ])
      if (!defined(output_name)) {
        output_name = executable_name
      }
    }
  }
} else {
  template("executable") {
    _basic_executable(target_name) {
      target_type = "executable"
      forward_variables_from(invoker, "*", [ "visibility" ])
      forward_variables_from(invoker, [ "visibility" ])
    }
  }
}

template("test") {
  if (is_kernel) {
    not_needed(invoker, "*")
    not_needed([ "target_name" ])
  } else {
    _basic_executable(target_name) {
      target_type = "test"
      testonly = true
      forward_variables_from(invoker,
                             "*",
                             [
                               "target_type",
                               "test_group",
                               "testonly",
                               "visibility",
                             ])
      forward_variables_from(invoker, [ "visibility" ])

      if (!defined(output_name)) {
        output_name = "${target_name}-test"
      }
      output_name += toolchain.output_name_suffix
      if (!defined(output_extension)) {
        output_extension = toolchain.executable_extension
      }

      # TODO(get_metadata): shlib exclusion required only due to dismal kludge
      if (!defined(toolchain.shlib) || toolchain.label != toolchain.shlib) {
        if (!is_host && !defined(install_path)) {
          if (defined(invoker.test_group)) {
            test_group = invoker.test_group
          } else {
            test_group = "sys"
          }
          install_path = "test/$test_group/$output_name"
          if (output_extension != "") {
            install_path += ".$output_extension"
          }
        }
      }
      if (is_host) {
        metadata = {  # TODO: host test metadata
        }
        # TODO: variant_suffix_metadata = { ... }
      }
    }
  }
}

template("host_tool") {
  assert(!is_kernel, "host_tool() targets don't work in kernel toolchains")
  _basic_executable(target_name) {
    target_type = "host_tool"
    forward_variables_from(invoker,
                           "*",
                           [
                             "target_type",
                             "visibility",
                           ])
    forward_variables_from(invoker, [ "visibility" ])
    if (!defined(output_name)) {
      output_name = target_name
    }
    output_name += toolchain.output_name_suffix
    if (!defined(output_extension)) {
      output_extension = toolchain.executable_extension
    }
    if (is_host) {
      tool_executable = "$target_out_dir/$output_name"
      tool_extension = ""
      if (output_extension != "") {
        tool_extension = ".$output_extension"
      }
      metadata = {
        # List of tool binaries that could be presented to users' command line.
        tool_executables = [ get_path_info(tool_executable, "dir") + "/" +
                             get_path_info(tool_executable, "name") +
                             toolchain.variant_suffix + tool_extension ]

        # See host_tool_action().
        host_tool_barrier = []
        if (defined(toolchain.host_run_env)) {  # TODO: sanitizer case
          host_tool_action_script = [ "/usr/bin/env" ]
          host_tool_action_inputs = tool_executables
          host_tool_action_args = toolchain.host_run_env +
                                  rebase_path(tool_executables, root_build_dir)
        } else {
          host_tool_action_script = tool_executables
        }
      }
      variant_suffix_outputs = [ tool_executable + tool_extension ]
      variant_suffix_metadata = {
        tool_executables = variant_suffix_outputs
      }
    }
  }
}

# These are all the target types (both stock GN and Fuchsia templates) that
# compile `sources` with the $current_toolchain tools.  All these get a
# default `configs` below, so targets use `configs +=` and `configs -=`.
_compile_target_types = [
  "driver",
  "executable",
  "host_tool",
  "library",
  "loadable_module",
  "shared_library",
  "source_set",
  "static_library",
  "test",
  "test_driver",
]

# ${toolchain.configs} gives the initial `configs` set for every compile
# target in this toolchain.  Targets use `+=` rather than `=` unless they
# are explicitly doing `= []` to remove all the toolchain defaults; they
# can use `-=` to remove specific members from the default set.  In the
# Fuchsia build, `configs` winds up being used as `deps`, so things listed
# in ${toolchain.configs} can actually be any target type, not just config().
foreach(target_type, _compile_target_types) {
  set_defaults(target_type) {
    configs = []
    foreach(config, toolchain.configs) {
      # Either it's an absolute label string or it's a scope with filters
      # and mutators.  See define_environment().
      if (config == "$config") {
        configs += [ config ]
      } else if (!defined(config.types) || config.types + [ target_type ] -
                                           [ target_type ] != config.types) {
        configs += config.add
        configs -= config.remove
      }
    }
  }
}
